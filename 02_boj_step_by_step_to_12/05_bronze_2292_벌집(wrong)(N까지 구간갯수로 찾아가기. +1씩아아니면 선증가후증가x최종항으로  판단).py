# import sys
# # Python의 경우, 재귀함수 깊이 제한 늘리기 필요
# sys.setrecursionlimit(10**9)


# 점화식을 구했지만 너무 오래걸렸다...
# AAA 각 구간 마지막항이 규칙을 가짐 -> 
# AAA 58번방까지 누적해서 새로운 데이터가 구간마다 쌓였다.
# -> 1부터 각 구간마다 누적되는 갯수의 합을 제껴서, 통과시키게 만든다.

# N :     1  /  2 ~ 7  /  8 ~ 19  /  20 ~ 37  / ..57~./ 58
# 갯수 : 1개 /   6개  /   12개   /   18개   / ...6(k-1)개 / 
# 출력 :  1  /    2    /     3    /     4    / ... k/ 

#  N을 찾아가려고 한다면, 
# 1방 -> 1개 
# 2방 -> 6개 
# 3방 -> 12개  (6*2)
# k방 -> 6*k-1개 까지 누적해서 갔어야한다.
# -----
#       N번방이 k방은 통과했지만, k+1방은 통과못하였다? -> k+1번으로 움직여서 온다.



# https://wlstyql.tistory.com/50


# 내풀이1 - 점화식
 
N = int("211")

def an(n):
  return 1+3*n*(n-1)

if N < 2:
    print(N)

for k in range(1,N):
    if an(k) < N and N <= an(k+1):
        print(k+1)
        break
 

# 내풀이2 - 구간p를 증가시킴에 따라, x를 N에 듬성듬성 추격시키기
# - < N 까지 수행하여, 더해질때 N을 넘어선 x로, N구간에 도착한다.

# 벌집, 분수 -> 누적N이 (1구간증가시 규칙이 있는) 구간의 갯수마다 규칙이 있을 때
# -> N까지 몇구간 갔는지를 while로 구간갯수만큼 더하면서 + 몇번째 구간인지도 카운팅
# -> range는 +1밖에 안되서 하나하나씩 밖에 증가를 못한다
# -> 구간갯수만큼 while문을 듬성듬성 -> N을 지나감 -> 마지막 구간만 빼서 안쪽으로 안착.

N = int("")

# x ->N : 1 / 2~7 (6) / 8~19(12)개 / 20~37(18개) / ... N ../
# 최소방 : 1 / 2       /  3 

# 규칙구간 누적의 N이 몇구간까지 갔는지, 구간을 빼주며 파악한다


# 1. 
# 1은 규칙이없다. 0부터 시작못한다. 1부터 시작해버리고
# 1부터 시작 및  1일 때를 예외처리해버리자.
# +1 구간 증가시마다 6(k-1)개씩 늘어난다.
# 1번째 항은 예외다 -> 아예 첫항으로 주자. -> 선처리 후증가 -> 
# - but 후증가로 <= N으로 주면 안띠어 넘는 경우가 생긴다.
# - 무조건 띄어넘어서 한타임 줄이게.. < N으로 가야한다.
# 여기선 처리의 개념X / +1씩 증가X 없으므로.. 다 선증가 개념??
# - 최종항을 대입해보고, 거기서 판단하여 조건의 등호를 정하자!! 

partition = 1 
k = 1 # partition+1마다, 6(k-1)개씩 누적됨.

# 2. 
# 후증가는 [ <= N ] 시에만 N까지를 의미한다. 
# - 여기선 range의 +1씩이 아닌 것을 고려하며
# - k : partition이 증가시마다 규칙에 따라 늘어나는 누적합
# - 후증가 최대항 
# -- 1씩 커진다면? 최대 N 수행했을 것임
# -- N-1에서 이미 N을 넘어버려 N-1에서 끝난다.??
# -- 0-+1->1이라면, N에 안착되서 한번더할 수 있으나? 1부터 시작됨.
if N<=1:
    print(N)
else: 
    while k < N: 
        if N==1:
          print(partition)
          break
        partition+=1
        k+=6*(partition-1)
    print(partition) 
#print(N, k) N=13 -> k19 -> k가 N을 지나 한타임 더 갔다.(1씩 증가가 아니라 안멈추고)
#  p-1  | ... N ... (x) p |  ...
# N보다 작거나 같도록 더할라고 했는데 1구간 더갔다? = 그 위치가 실제 구간이다.

# N이 몇번째 i인지 구할 때는, 마지막 누적되는 구간만큼 빼준 뒤, 
# N - (p-1구간누적합) = i를 구한다. but 실제 위치한 구간은 partition은 그대로다.


# 3. i구하기
#  k-1구간까지의 합 for i
# k_1 = k - 6*(partition-1) # 누적합 갯수만 빼줬지, 실제 구간은 partition에 담겨있다.
