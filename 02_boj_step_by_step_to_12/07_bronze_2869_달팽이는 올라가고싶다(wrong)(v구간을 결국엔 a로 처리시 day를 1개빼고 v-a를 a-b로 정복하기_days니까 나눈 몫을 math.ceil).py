# ** +1이 아닌 while interval로 도는데 , 그 interval이 1이 되어서 반복문을 엄청나게 수행한다면?**
# -> 수학 방정식으로 풀고 몫과 나머지를 활용해라

# from input import Input

# print(Input.oneline)
# print(Input.multiline)

# 시간초과 코드다.
# - 5, 6번 문제를 풀다보니, for문으로 1부터 +1씩 도는게 아니라
# - 구간을 듬성듬성 나아가면서
# - 걸리는 일수/방수는 x로 따로 count -> +=1 씩해줬었는데,
# - 이 문제는 x에 따른 구간의 규칙은 없으나, 구간이 일정하지만, 구간이 1이라서

# - 마치 등차수열 1부터 처음가는 것과 같이 느려진다.

a, b, v = map(int, Input.oneline_2.split()) 
# AAA 반복문이 불가할땐, 수학 방정식을 풀어야한다
# AAA 방정식마다 나누는 경우의 수는 if, else로 나눈다.
# AAA 방정식은 // 나눈 몫 , % 나눈 나머지를 이용해서 푼다.

# days :1일 | 2일    |..n일.   | n+1일 |
#   (a-b)  | (a-b)  | (a-b)   |v  
#   (a-b)  | (a-b)  |    (a)v | 

# 1) 낮의 a로 정복되는 경우 :  -> 판단용 v-a가  a-b로 나누어떨어지는 경우?
#    (days(n-1)) * (b-a) + a  >= v 
# 2) 낮의 a로 정복안되는 경우, b로 내려서 하루를 본 상태에서 + 그날의 a로 정복 (그날 a로 정복안됬다면, a-b는 더 작으니 더 정복안된다.)
#    (days(n)) * (b-a) + a >=v
#  ㅠ_ㅠ 나는 a로 정복안되면, a-b로 정복한다고 까지 밖에 생각안했음.. a-b는 더짧은데.. 그 담날의 a로 정복해야함..

# 어차피 정복기준은 v-a다. 어떤 경우에는 n-1*a-b + 1로 되고, 어떤 경우에는 n*a-b + 1로 될까?

# 어차피 마지막은 a로 정복 -> v-a를 a-b로 정복해야한다. 
# result =  1 + (v-a)/(a-b)를 하면 끝나나?
# 이후생각) +1은 끝의 a로 정복된다는 의미이다.  
# 이후생각) 그렇담 v-a에 일정구간a-b로 정복해야하는데, a-b로 딱 나눠서 떨어지는 경우도 있고 / a-b로 넘치는 경우도있다. (a가 그만큼 길어서?)
# if % (a-b)   else: (나누어떨어지는 경우)로 나눠서 풀어야할듯하다. 근데 어떻게 되었든 간에,, a-b로 딱 or 
# **a보단 못하지만 a-b가 조금 남는 경우 ex> v = a + (a-b)*n 에서 +a로 v를 넘쳤음. -> 그러나 (a-b)는 최소 m개 필요할 것이고,,, 그게 1.5개 이렇게 나올 수도 있다.
# **  1(a-b) + a < v 로 a로 가더라도 조금 모자라다.    2(a-b) + a = v 이전에 충분히 정복이 된다. 1.5(a-b)에서 +a시 정복했다.
# ** 그래도 하루는 int단위이므로 2(a-b)로 ... 올림을 해줘야한다.
# a+(n-1)(a-b) < v < a + n(a-b)  ->   (n-1)(a-b) < v-a < n(a-b)    v-a가 안나누어 떨어진다면.. 나머지가 있따면, 올림해줘야한다..?
# n-1(a-b) + a 보단 크고.. 당근 n(a-b)보단 클테고.. < v  < 다음날엔 +a로 정복됨 + n(a-b)
# -> 고정된 a-b를 나두고, a를 고정시켰다.. 많이 빼웠다. 2/3a로도 정복될건데 1/3a더빼줬다고 생각해보자.
# -> v -2/3a = (n-1)(a-b)   a-b구간으로 나누어떨어지진 않는경우에는... 몫(count) + 1더해줘야한다.

# **만약, 1.5 days(a-b) + a로 겨우 정복됬다고 치자.
# **근데, 1days+a로는 절대 못간다... -> 차라리 2days를 줘야한다. -> 나머지가 있는 경우에는.. count를 올림시켜야한다..

# ** 결국에는 v-a를 (a-b)일정구간으로 나눈 몫 -> count -> a만큼 간 것 때문에 +1해줘야함
# **                               나눈 나머지 -> 있다면 +1 없다면, 그대로 0
# **            **0이라면 그냥 두고, 소수점  0.1 0.001 이라도 있다면 +1이 해주는 것이 바로 올림(math.ceil)을 이용한다.
print("방정식 result >>> ",1 + (v-a)/(a-b)) # 1.25 days가 나온다.
# days는 무조건 올림해야할 듯
import math 
print(math.ceil(1 + (v-a)/(a-b)))



# ## 답은 나오는데, 시간초과 코드
# interval = a-b
# days=0
# while  (v -a)> 0:
#     days += 1 
#     v -= interval
# # v-a <= 0 상태다? 다음날 바로 정복된다.! +1일만 해주자.
# # 낮으로만 0보다 작아진다. -> +1일만 더 하는 도중에.. 도착한다. 
# # 구간마다는 b-a를 빼지만, 다음날 정복가능 여부는 (남은길이-a)로 판단, (남은길리-(a-b) 아님!!)
# print(days+1)
  