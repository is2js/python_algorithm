# 링크: https://programmers.co.kr/learn/courses/30/lessons/42862
# 느낀점 :
# * 양쪽으로 인접항고려시 우선방향 선택 + hash 헛개비range(N+2)추가하면서 초기화 후 조건을 통해 고려안되게
# * 인접한list의 slicing = [1,1] 할당센스..
# * hash (counting정렬, 계수정렬)에서  n은 너무 많아 메모리 차지, 작동하는 lost 0은 적고 대부분이 가만히 있는 1 
# -> 다른 방법고려 


# 해설 모음:탐욕법 적용 가능성 확인
# 이 문제에서 탐욕법을 적용하려면 빌려줄 학생들을 “정해진 순서”로 살펴야 하고, 이 “정해진 순서”에 따라 우선하여 빌려줄 방향을 정해야 함.
# 1 .[+-+-+] 일 때, lost의 좌우가 다 가능하니
# * -> 기준을 정해서 왼쪽(작은번호)에서 오른쪽(높은번호)로 빌려주는 식으로 하거나
# * <- 기준을 정해서 오른쪽(높은번호)에서 왼쪽(작은번호)으로 빌려주는 식으로 하거나
# if [-+-++]라면.. ->방식은 1번을 도와줄 작은놈이 없어져버린다.
#      <- 방식은? [1111+]로 가능하다..    [   +-]라면?.. 안될껀데????
# * 진행방식순으로 <- 뒤에서 앞으로 땡겨주는 것을 <우선순위>로 한다
# ** if 땡겨주고도  <후순위로서 뒤쪽에> if 뒤도 모자랄땐 뒤까지 본다.

# * 풀이1) N 2~30 : 이미.범위.정해짐 -> hash(배열), radix 정렬, 계수정렬, Couting정렬
# ** 이 때, 0~N도 아니고, 0~N+1 배열을 만들기 위해 range(N+2)를 활용한다?
# ** <- 방식일 땐, i-1 ==0 and i ==2인 상태만을 의미한다. 이 때만 나눠준다.
# ** <- 방식이라도, i == 2 and i+1 == 0 인 경우에도 나눠준다.
# ** i-1, i, i+1까지 보려고 일부러 배열을.. n+1 index까지 집어넣어놨음..
# # --> 인덱스 검사가 필요없어진다.
#     1   2   3   4   5   6   7   8   9   10
# 1   1   1   1   1   1   1   1   1   1   1   1 
# -> 무조건 1로 초기화해주기. 매 단계에서 내 앞의 번호, 뒤의 번호를 살펴봐야 하므로 앞뒤에 허깨비 1을 붙여준다.(고려하지 않는 것으로 치기 위해)

# 1   1   2   1   1   2   2   2   1   2   1   1 
# -> 체육복 가져온 사람 1씩 늘려주기(앞과 뒤의 1은 허깨비)

# 1   0   2   0   1   1   2   1   0   2   1   1 
# -> 도난당한 체육복 1씩 감소

# 1   1   1   0   1   1   2   1   1   1   1   1 
# -> 번호가 작은 쪽부터 살펴나가서, 여분이 있는 사람은 번호가 작은 사람에게 한벌을 빌려주게 한다.
# -> 2번이 1번에게 빌려주고, 9번이 8번에게 빌려준다.



# * 풀이2) set을 이용해서 -> 빌려줄 수 있는 학생들의 리스트를 해시를 적용해서 상수 시간에 처리하게 만들 수 있다.
# --> set 데이터 타입 이용하기
# ** 여분 + 도난 -> 제자리(1)를 set 교집합으로 구한다
# ** 도난 - 제자리 -> 순수 도난학생(0)을 set 차집합으로 구한다.
# ** 여분 - 제자리 -> 순수 여분(0)을 set 차집합으로 구한다.
# *** 순수여분 정렬 -> 순서대로 순회하면서 -> (순수여분-1) in 도난: 상태면 체육복 건네준다. by 도난.remove(x-1) 
# *** 그 뒤 순서(차순위)로서 (순수여분+1)이 도난상태면 remove해서 구해준다.
# ** 전체 n - 구해주지못한len(도난)하면,, 여분or제자리의 총 숫자다.
# --> 정렬이 들어가서 NlogN이다. but N이 작아서 통과는 가능하다.
# 2. 해설 2
# - 학생 수가 매우 많고, 여벌의 체육복을 가져온 학생은 매우 적다면(k) 위 방법은 굉장히 비효율적
# 여벌의 체육복을 가져온 학생들의 번호(reserve)를 '정렬'(복잡도는 O(klogk))하고
# 이것을 하나 하나 순서대로 살펴보면서 빌려줄 수 있는 다른 학생을 찾아서 처리한다. -> 해시를 적용해서 상수 시간에 처리!
# 시간 복잡도는 O(klogk)
# 해설3. n은 너무 큰데 lost가 너무 작으면 메모리의 낭비가 일 수 있다.
# 이 방법은 정렬 때문에 알고리즘 복잡도가 O(n log n)이 되지만, 위의 경우 더 도움되는 방법

# =====================풀이방법1=========================
def solution(n, lost, reserve):
    lst = [1] * (n+2) # 1부터 N까지만 쓰는데, 양쪽으로 이웃해있어서  n+1도 포함시키도록 선언한다.
    # [0] * n -> 갯수가 n개지 index는 n-1까지로 생성된다.
    
    # 여분은 +1씩 해서 2를 만들어준다.
    for i in reserve:
        lst[i]+=1
    for l in lost:
        lst[l]-=1
        
    # 이제 체육복을 빌려주는데, i번째 기준 양쪽으로 다 도와줄 수 있다.
    # - 기준을   낮<-높     [i-1 <- i] 를 기준으로 잡아준다. 반대쪽 [i-> i+1]은 그 뒤에도 가능할때 고려한다.
    # -> 이것도 될 것 같은데..흠..
    
    # i를 1~n까지 살핀다 [i-1], [i+1]을 사용하나, n+1인덱스가 1로 차있음.
    for i in range(1, n+1):
        # 1) 왼쪽에 줘야하는지부터 <우선순위>로 살펴본다.
        # -> [0]은 이미 1이 차있으므로, 모자라서 왼쪽으로 건네주는 작업은, <배제>되는구나! -> 예외처리 안해줘도 된다.
        # -> 정확히 lost와 reverse 상태인지를 구체적으로 확인해서, 그상태일때만 준다.
        if lst[i-1] == 0  and lst[i] == 2:
            # sense) 인접한 한 배열의 할당은 slicing = list조각 을 그대로 대입해도 된다.
            lst[i-1:i+1] = [1, 1]    
        # 2) 후순위로 정해서, 뒤쪽에서 처리한다.
        # -> [n+1]도 이미 1이 차있으므로 모자라서 건네주는 일은 없다. 예외처리 방지용
        elif lst[i] == 2  and lst[i+1] == 0:
            lst[i:i+2] = [1,1]
        
    # 이제 0과 n+1속 1이상인 것의 갯수를 구한다.
    return len([x for x in lst[1:n+1] if x>0])

# # =====================풀이방법2=========================
# -> 나는 버림
# def solution(n, lost, reserve):
#     s = set(lost) & set(reserve)
#     # set, 집합을 &으로 연결하면 이 두 집합의 교집합을 뜻한다. 교집합을 s에 담는다. s는 여분의 체육복이 있는데 도난당한 학생.
#     # set의 복잡도는 배열 길이에 비례한다.
#     l = set(lost) - s # lost는 체육복을 도난당한 학생-reserve에도 있는 학생(빌릴 필요 없는 학생) 이렇게 차집합 연산! l은 체육복이 0개인 학생.
#     r = set(reserve) - s # 여분이 있는 학생 - 여분의 체육복이 있는데 도난당한 학생. r은 체육복을 빌려줄 수 있는 학생.
#     # set의 복잡도는 배열 길이에 비례한다.
#     for x in sorted(r): # O(klogk)
#         # 조건 중요하다!! 오름차순으로 먼저 살펴보고, 그다음 내림차순으로 살펴봐야 한다.
#         if x - 1 in l:#나보다 번호 작은 학생이 체육복을 도난당한 학생이면
#             l.remove(x-1)
#         elif x+1 in l:#나보다 번호 큰 학생이 체육복을 도난당한 학생이면
#             l.remove(x+1)
#     return n-len(l) #전체 학생에서 체육복 0인 학생들 빼준걸 리턴!
























#=== 내가 찍어서 맞춘 풀이=========
# def solution(n, lost, reserve):
#     max_uniform = 0
#     tot = [1] * n # 1~n번 -> 인덱스는 0~n-1

#     for r in reserve:
#         tot[r-1]+=1
#     for l in lost:
#         tot[l-1] -=1
        
#     print(tot)
    
#     # 현재 0인 사람을 양옆에서 채워야한다.
#     for i in range(len(tot)):
#         # 만약 현재 0이다.
#         if tot[i]==0:
#             # 처음은 오른쪽에서만 도움을 구한다.
#             if i==0:
#                 print("첫번재진입")
#                 if tot[i+1]>1:
#                     tot[i+1]-=1
#                     tot[i]+=1
#                 # 도움이 요청안되는 상황이라면 그냥 놔두고.. 나중에.. 0은 안센다.
            
#             # 마지막은 왼쪽에서만 도움을 구한다.
#             elif i==len(tot)-1:
#                 print("마지막진입")
#                 if tot[i-1]>1:
#                     tot[i-1]-=1
#                     tot[i]+=1
                    
#             # 만약 처음과 끝이 아니면 양쪽에서 도움을 구한다.
#             else :
#                 print(f"양쪽진입 {i}")
#                 # 일단 작은족에서 먼저 도움을 구하는ㄱ ㅓㅅ으로  해보자.
#                 if tot[i-1] > 1 :
#                     print(f"양쪽진입 {i-1}에게 받아옵니다.")
#                     tot[i-1] -=1
#                     tot[i]+=1
                    
#                 elif tot[i+1] >1 :
#                     print(f"양쪽진입 {i+1}에게 받아옵니다.")
#                     tot[i+1] -=1
#                     tot[i]+=1
#     print(tot)
#     answer = len( [x for x in tot if x>0])
#     return answer