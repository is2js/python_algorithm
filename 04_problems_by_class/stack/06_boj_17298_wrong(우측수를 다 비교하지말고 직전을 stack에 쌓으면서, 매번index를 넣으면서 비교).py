# 느낀점: 
# 해설강의: https://www.youtube.com/watch?v=XwG-QcBQ9-I
# -> i번째수를 i+1, i+2, ..., n-1까지 비교하는 것보다, 
# --> i-1, i를 비교해보되, (i-1)을 <매번stack에쌓고, 조건불만족시 쌓아두면서, 다음번엔 가장 최근index=가장우측index와 먼저비교>하기 위해서, 
# --> 못찾으면 stack에 넣었따가 while pop조건에 의해 담에도 발견될 수 있게
# --> 직전항을 stack에 넣은 체로 현재항과 비교해나가기

# * <최대한 바로 오른쪽>의 큰값 찾기 -> 직전값이 나보다 작아야됨. 내가 오큰수. 직전값=stack에서 뒤에서부터 꺼내서 <최대한 가까운 왼쪽> 꺼내야지. / 직전값이 나보다 안크면 stack에 쌓아두었다가, <다음턴에 다음턴직전값-pop이후 비교되도록 쌓아두기>
# * 탐색의 for문을 줄이려면, 역발상 & 시복->공복으로 변환해서 매i 기록 & <i와 직전것>비교로 찾아가고 <못찾으면 쌓아뒀따 담에 최근 것부터하기>
# * <쌓아두며, 못찾아도 매번 최근 것, 직전항부터>과 비교하려면, 일단 stack[-1]로 비교전 매번 쌓아놔야 -> stack[-1]이 직전inex로 업데이트 된다.
# -> while stack and stack[-1]은 stack에 들어가있는 a[i-1]며, 이것과 a[i]을 비교해서, 쌓던지 pop으로 꺼내서 먼저 기록한다.
# * 1. <찾으면 pop해서 기록하고>  < 못찾았으면 다음에 찾도록(while)시도할테니 쌓아두되, 제일 못찾은 것 중에  제일 최근 = 제일 오른쪽에서 찾아라>
# * 2. <pop해서 찾고, 못찾은 것은 쌓아두되 담턴에 최근것부터 해결> 시 -> [pop해서 찾은 것은 기록]해두어야한다.
# * 3. i번째에는  0~i-1까지가 stack에 있을 수 있다. (다못찾을시) 이런 상황을 연출하려면
# * -> 즉, stack[-1]이 i-1를 유지하려면, <루프안에서 append(i)>를 하고 끝내야한다.
# --> 직전index를 stack안에서 비교하고 안되면 쌓아두려면, 매 index를 stack에 append하고 끝나야한다.
# ex>
# 9548
# -> 9 stack
#s[-1] a[i]
# 9    5 -> 조건만족안하니 5도 stack에 9 5
# 5    4 -> 조건만족안하니 4도 stack에 9 5 4
# 4    8 -> 조건만족-> [pop된 4]의 오큰수 8 저장
# 5    8 -> 조건만족-> [pop된 5]의 오큰수 8 저장
# 9    8 -> 조건만족안하니 8도 stack에 9 8

# 최종 스택 : [9 8] -> 
# stack에 남아있다? 오큰수를 못찾았다 -> 해당 수의 pos에 -1표시를 해야한다.
# -> stack에 index를 저장해야한다.

################ Input From input.txt ################
import sys
from pprint import pprint
sys.stdin = open("./input.txt", "rt")

### 백준용
### import sys
### input = sys.stdin.readline
# 단계별로 푸시는 분: https://developer-ellen.tistory.com/33 # 고민 많이 하시는 분이라 챙겨놓음.
######################################################
import sys

n = int(input())
a = list(map(int, input().split()))

# 0. 바로 오른쪽의 큰값 찾기 -> 직전값이 나보다 작아야됨. 내가 오큰수. 직전값=stack에서 꺼내야지.

# 1. 각 숫자 a[i]마다 [우측수들이 나보다 큰지 하나씩 비교하며 & 큰 수들을 순서대로 가지고 있어야한다.] -> 100만개 * O(N^2)
# ->  a[i]와 직전 것을 비교하되, 못찾으면 쌓아두고 담에 비교하려면 (stack에 넣으면서 비교한다.)  & 담(a[i+1])에 구하더라도 <쌓아둔것보다 직전 것[i]부터 먼저 비교>하려면 stack에다가 index를 쌓아둔다.
# --> a[i-1]과의 비교가 아니라, [stack에 넣어놓고 비교되어야지] 못찾으면 쌓아두거나 찾을 최근순으로 빼낼 수 있다.
# -> 쌓아둘땐, index를 쌓아두며, [매 index를 append]해줘야지, 담턴에서 stack[-1]에 직전index와 비교할 수 있다.
# -> 조건만족하여 오큰수 발견시 그 index를 pop을 통해 가져오며, 기록해두어야한다.

stack = []

# 3. 찾은 오큰수 및 그 때의 index를 기록하는 <index를 가진 n개의 배열>
result = [-1] * n

for i in range(len(a)):
    # 1. i번째수와 직전것을 비교하는데, 못찾을 시 쌓아두면서 & 최근순으로 찾으려면 a[i-1]이 아니라 stack에 넣어놓고 stack[-1]과 비교되어야지 쌓아둘 수 있다.
    while stack and a[stack[-1]] < a[i]:
        # 2. stack[-1]은 stack에 들어가있는 a[i-1]며, 
        #    이것과 a[i]을 비교해서, 쌓던지 pop으로 꺼내서 먼저 기록한다.
        #    현재 a[i]은 오큰수다.(직후 바로 오른쪽 큰 값)
        #    쌓아둔 다음 값도 오큰수의 대상이 되는지 확인하게 stack[-1]을 pop으로 꺼내고 기록하기
        
        # 4. 해당index에서의 오큰수는 a[i]임을 기록한다.
        result[stack.pop()] = a[i]

    # 0. stack에 <쌓아두며, 못찾아도 매번 최근 것, 직전항>과 비교하려면, 일단 stack[-1]로 비교전 매번 쌓아놔야 -> stack[-1]이 직전idnex로 업데이트 된다.
    stack.append(i)

# 아직 스택에 남아있으면, 오큰수를 못찾은 index들이다. -> -1을 넣어야하지만 이미 들어가있음.
if stack:
    pass

print(result)





# # 1. 나보다 오른쪽에 있는 값들을 접근한다. -> i-[i+1~n-1] <큰수>탐색을 못쓴다면
# #  -> 각 i에서 <나보다작은수> 탐색하며 [0 ~ i-1]을 덮어쓰기로 update를 해야한다.
# #  -> i번째 정보가 없을 경우의 default값으로 넣어주자.
# result = [-1] * n 
# pop_list = []
# stack = [] # * i번째항을, 오큰수로 생각하는, 아직사용안된, 나보다 작은 수의 index
# # * stack에 집어넣는다 -> 1회성으로, 조건만족하는(나보다 큰) 가장빠른(stack의 pop & for문) 다음index(for)를 기록한다.
# # * pop이 버리는게 아니라, pop조건만족하는 것을 뽑아 기록하는 용도로도 쓰인다.
# for i in range(len(a)):
#     # 2. i번째보다 큰수 -> i번재일때, 나보다 작은 0~i-1들을 다 뽑아야한다.
#     # -> 이사람들(0~i-1) 입장에서, i번째 나는, <오른쪽 큰수>로서 오큰수의 후보가 되었을 것이다.
#     # -> 하지만 내(i) 입장에서는, 0~i-1 <왼쪽&나보다 작은 수>이어야한다.
#     # --> 나는 후보들을 다 뽑을 필요가 없다. 0,1,2 나아가면서 차근차근 stack 중 가장왼쪽 채워나갔을 것이기 때문에, 직전만 비교한다?
#     # * stack[-1]에 있다? stack.append()로 i-1로 집어넣었으며, 아직 사용안된 직전 or 가장최근 index다. <나랑 가까우니 빨리 오큰수로 나를 선택해라>
#     while stack and a[stack[-1]] < a[i]:
#         # 나를 오큰수로 삼는(나보다작은), i-1 이전(나보다 왼쪽)의 index를 뽑아서
#         # 나를 오큰수로 등록해라. pop()으로 돌아가면서 다 기록해라.
#         # 7-> 2야 기록해라.pop&result기록 -> 5야 기록안했으면 기록해라.
#         # * -> stack에 들어갔다나왔다한다? -> 딱 1번만 기회를 가진다. -> 앞에서부터 기록해서 이미기록되었으면 안나온다.
#         # * 1번밖에 안나오는 stack속 값을 앞에서부터 기록한다? -> 뒤에선 안나와. 가장 왼쪽만 기록됨.
#         # * -> stack에 index를 기록하고 조건에따라 pop? <입력된 순서순으로 딱 한번만 사용> 
#         #  i번째라고 해뽰자.. 조건에 맞는 stack[-1]은.. pop->result 기록될 index는 <기준값, 현재항a[i]> 가장왼쪽놈들 순으로 잡아갈건 다 잡아갔다!
#         # my) 나올때까지 pop이 아니라, [for i 조건에 맞으면 바로 pop = 각 stack속 값마다, 순서대로 돌아가는 a[i]의 먼저나온 순으로 먼저 선점되어, 자동으로 [조건에 맞는 것 중 가장왼쪽 값] a[i]가 선택된다.
#         pop = stack.pop()
#         pop_list.append(pop)
#         result[pop] = a[i]
#     stack.append(i)

# # print(pop_list)
# # index를 저장해놓는다? -> 원래배열 / 정답용배열 따로 다있음.

# # a = [3, 5, 2, 7]
# # i     0           1 
# # a[i]  3           5
# # stack  []->[0]-> []
# # stack[-1]   a[0]
# # answer [-1, -1, -1, -1]



        



    





# 1. 이미 for i -> O(N)인 각 i에 대해서,  i+1~ n-1까지 for문을 돌리기엔 n이 10만이 넘어감..
# # -> Count정렬의 [범위가 정해진 수] -> 범위 - index에 매칭한  list 처럼
# # -> 각 i에 대한 정보 - index에 매칭한 list를 써야한다?
# # -> 

# # 2. i보다 우측 -> stack은 <순서대로입력만 미리 되어있으면> pop으로 <우측값만 까서볼수있다>. 
# # -> i까지 pop, 그 이전은 안꺼내도 되니까?
# # -> pop조건 = (우측에있으면서) pop하면서 [i]보다 큰 것을 챙기는데, i이후만 & 최대한 많이 깐 것?


# # 0. 결과적으로 각 i번째 오큰수를 찾은 결과가 미리 만들어져야함. 
# # -> 결과변수에는.. 0을 많이 넣지만, 문제에서 예외처리 변수가 있으면 그걸로 준다.
# result = [-1] * n # 여기다 각 i마다의 오큰수를 넣어줄 준비를 한다. 

# # # 1. 순서를 가진놈들을 <조건에 안맞는 놈들은 pop>하면서 <맞는놈들은 append>하면서 재배열 후
# # # -> 가장 왼쪽값?? 을 기록???
# # # - 값이 아니라 index를 stack에 활용한다?
# # # -> 각 i번째 index를 다 밀어내고, 맞는 index만 채운다?
# # stack = []
# # for i in range(len(a)):
# #     # -> 각 i마다, 오큰수를 stack에 쌓고 그 중 가장 왼쪽만 남도록 ,pop조건을?
# #     # my) 나보다 오른쪽의 값들?? -> [a]는 오른쪽에서 pop하면서 시작하기?
# #     while stack and a[stack[-1] ]< a[i]:
# #         # [9 5 4 8]에 대한 index 0,1,2,3을 돌면서
# #         # index를 stack에 넣어준다.
# #         # 0 들어간 상태
# #         #  a[0] < a[1]: 드가있는 index들이 i번째의 값보다, 값이 클 수록 우선순위가 높아서 pop시킨다.
# #         # -> 작은놈의 index는 stack에서 빠짐과 동시에
# #         # -> result에는 그 pop된 index의 수 자리에, i번째 수를 넣어준다?
# #         stack.pop()

# # 1. 값이 아니라, 순서대로 01,2,3,n-1의 index를 stack에 담는다.
# # -> 직전 값과 비교가 아니라, [직전자리]와? 혹은 [직전자리의 xxx]과 비교해서 pop을 한다.
# # --> 직전[position]의 뭔가와 비교하고 싶을 때,,, stack에 [조건에 맞는] = [조건에 안맞는 것 pop 한 뒤, append만]

# # 2. 직전position과 현재position[i]의 값을 비교해서, 현재보다 작은 값이면, 그 값의 position들을 stack에서 제거한다.
# # -> 그 때마다 [i-1]? [직전까지의 조건]일 때는 들어갔다가, [i]일 때는 나오게 되는 놈 -> [i-1]일 때의 정답
# # -> pop되는 값도 챙겨준다.
# # --> my) ~할때까지 pop -> 그담 append(1개)작전은.. equal 조건을 만족하는 1개만 들어가 있다.?
# # my) 비어있는 stack = []에서 시작하였다면,
# #     while stack[-1]은 직전까지의 조건을 만족하는, i-1보다 더 위대한, 살아남았떤 1개의 고마운 값...!
# #     stack.pop()으로서 값을 챙겨준다.-> [i-1일때, 직전까지 조건을 만족해서 들어갔던 놈]
# stack = []
# for i in range(len(a)):
#     print(f"{i}번째 :>> stack:{stack} / result:{result}")
#     # 2-2. [직전까지 조건을 만족했던 index]인 stack[-1] index의 값과 비교해서, 값이 더 크면,
#     #      값이 더 크면, 그 때의 stack[-1], 전주인을 stack.pop()으로 내보내서, 그 때의 index를 기록하는데
#     while stack and a[stack[-1]] < a[i]:
#         # 2-3. i번째 값보다 더 작은 값을 가집니다. 그 값은 
#         #      while pop&기록까지 하니, 맨 마지막 기록만 남을 것이다.
#         #      -> 값이 같아질 때까지 진행되면서, stack상 가장 왼쪽값만 pop()으로 기록된다.
#         #      -> while pop&기록의 덮어쓰기. -> 그 때의 값a[i]와 <pop조건 만족 & stack상 제일 왼쪽만 기록>
#         print("stack-pop전 :>>", stack)
#         # 2-4. 직전에서 a[i]보다 큰 값이 들어가있는 그 position을 pop한 뒤, 그 직전의 
#         # 3에 대해서, 5가 result에 들어가야하는데, 그 5의 index는 조건을 만족해서 들어간 stack에서 꺼낸값이다.
#         # 3 -> 1) 5,2,7 중 5,7을 뽑아내고 -> 그 값들의 제일 왼쪽값을 가져오기 위해서는
#         #   -> 2) 그때의 5,7의 index를 순서대로 stack에 담았다가 while []pop 덮어쓰기 해버리면, 맨 왼쪽꺼만 기록된다.
#         #   -> 3) 이 때, pop조건을.. i번째에서 -> i-1번쨰를 채우는 식으로 해야한다.
#         #   --> pop은 1번 채우고 난 뒤 일어나는 것이므로. i-1번재에서, <직전값?ㄴㄴ 직전에 담긴 많은 값들>을 대상으로 pop덮어쓰기해서 가장 왼쪽값만 골라낸 뒤
#         #  -->  그것을 result변수에 <그때의 값>과 같이 기록한다.
#         result[stack.pop()] = a[i]
#         print("stack-pop후 :>>", stack)
#         print("result :>>", result)

#     # 2-1. stack에는 index가 담긴다. 
#     # - 0부터 들어가며, 만약 오큰수를 못구했다치더라도, i는 계속 넣어준다.
#     # -> 그래야 i+1이.. 비교해서.. 처리하기 때문?
#     stack.append(i)
#     # my) stack append(i)와 stack[-1]은 직전index를 넣어주고 꺼내보는 것에 불과함?
#     # my) 직전인덱스의 값보다 현재i의 값이 크다?-> 현재i의 값이 오큰수 
#     # my) <나올때까지 pop>이 아니라 <만족하는 동안 후보들을 pop으로 계속 덮어써서, 가장 왼쪽후보만 남기기>
#     #     만약, 만족안하면? 기록X -> [-1]로 노기록시의 값이 미리 적혀있다.
#     # my) 0부터 차곡차곡들어가는 stack은 조건만족시 pop으로 빼서 기록해주는, index들이 반드시 들어갔다가 나오는, <직전index>를 모아두는 곳이다.
#     # <직전index>의 값보다 큰값이 나타날때마다 <직전index 자리에> 덮어쓰기 기록







# pos_stack = [] # 가장왼쪽 -> stack으로 해결할 것이기 때문에 큰 것만 담아준다.
# # i번째 값보다 큰 것이 나올때마다 순서대로 쌓아두고 싶은데, 직전거보다 더 큰게 나온다면?
# for idx, x in enumerate(a):
#     while pos_stack and pos_stack[-1] < x :


#     pos_stack.append()
    

#     # 2. 일단 stack에 append하는데, 값(X) 오큰수 후보 pos를 append한다.
#     #  -> 직전값(X) 미리들어간 [직전 오큰수 pos]보다 왼쪽일 경우, pop해해야지?
#     # a[i]번째 값보다 작으면 pop, a[i]번째 값보다 큰 경우?? push해야하지 않나..




# ========시간초과 내코드============
# candidate_nge = [0]*n
# print(candidate_nge)
# for i in range(len(a)):
#     r_greater_than_i = [x for x in a[i+1:] if a[i]<x]
#     # 우측슬라이싱을 100만개 -> O(N) * 더 N이하의 시간복잡도로 줄여야함
#     curr = a[i]
#     candidate_nge[i]



#     #print(r_greater_than_i)
#     # 봅았는데 없을 수도(맨마지막은 무조건)
#     if len(r_greater_than_i) == 0:
#         print(-1)
#     else:
#         print(r_greater_than_i[0])



